Frontend:
"use client";

import { useEffect, useState, ChangeEvent } from "react";
import { useAuth } from "@/context/AuthContext";
import { Product } from "@/types";
import {
  getProducts,
  addProduct,
  updateProduct,
  deleteProduct,
} from "@/services/products";
import Notification from "@/components/Notification";
import axios from "axios"; // Import axios for the upload

// Add imageUrl to the form state
interface ProductFormState {
  name: string;
  description: string;
  price: string;
  imageUrl: string;
}

const INITIAL_FORM_STATE: ProductFormState = {
  name: "",
  description: "",
  price: "",
  imageUrl: "",
};

export default function AdminPage() {
  const { token, user } = useAuth();

  const [products, setProducts] = useState<Product[]>([]);
  const [form, setForm] = useState<ProductFormState>(INITIAL_FORM_STATE);
  const [editingProduct, setEditingProduct] = useState<Product | null>(null);

  // ‚úÖ New state to hold the selected file for upload
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [isUploading, setIsUploading] = useState(false);

  const [isLoading, setIsLoading] = useState(false);
  const [notification, setNotification] = useState({
    message: "",
    type: "" as "success" | "error",
  });

  const showNotification = (message: string, type: "success" | "error") => {
    setNotification({ message, type });
    // Auto-hide the notification after 3 seconds
    setTimeout(() => setNotification({ message: "", type: "success" }), 3000);
  };

  const fetchProducts = async () => {
    setIsLoading(true);
    try {
      const data = await getProducts();
      setProducts(data);
    } catch (err) {
      showNotification("Failed to fetch products", "error");
    } finally {
      setIsLoading(false);
    }
  };

  const handleDelete = async (id: number) => {
    if (!token) return;
    if (window.confirm("Are you sure you want to delete this product?")) {
      setIsLoading(true);
      try {
        await deleteProduct(id, token);
        showNotification("Product deleted successfully", "success");
        await fetchProducts(); // Refreshes the list
      } catch (err) {
        showNotification("Failed to delete product", "error");
      } finally {
        setIsLoading(false);
      }
    }
  };

  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      setSelectedFile(e.target.files[0]);
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setForm({ ...form, [e.target.name]: e.target.value });
  };

  const handleEditClick = (product: Product) => {
    setEditingProduct(product);
    setForm({
      name: product.name,
      description: product.description,
      price: String(product.price),
      imageUrl: product.imageUrl || "", // Handle case where imageUrl is null
    });
    setSelectedFile(null); // Clear file selection when editing
    window.scrollTo(0, 0);
  };

  const handleCancelEdit = () => {
    setEditingProduct(null);
    setForm(INITIAL_FORM_STATE);
    setSelectedFile(null);
  };

  const handleSubmit = async () => {
    if (!token) return;
    if (!form.name || !form.price) {
      showNotification("Name and Price are required.", "error");
      return;
    }

    setIsLoading(true);
    let finalImageUrl = form.imageUrl; // Start with the existing imageUrl

    // Step 1: Upload the image if a new one is selected
    if (selectedFile) {
      setIsUploading(true);
      const formData = new FormData();
      formData.append("file", selectedFile);
      try {
        const res = await axios.post(
          "http://localhost:8080/api/upload",
          formData,
          {
            headers: {
              "Content-Type": "multipart/form-data",
              Authorization: `Bearer ${token}`,
            },
          }
        );
        finalImageUrl = res.data.url; // Get the URL from the backend
        showNotification("Image uploaded successfully!", "success");
      } catch (err) {
        showNotification("Image upload failed.", "error");
        setIsLoading(false);
        setIsUploading(false);
        return; // Stop if upload fails
      } finally {
        setIsUploading(false);
      }
    }

    // Step 2: Save the product with the (potentially new) image URL
    try {
      const productData = {
        name: form.name,
        description: form.description,
        price: parseFloat(form.price),
        imageUrl: finalImageUrl,
      };

      if (editingProduct) {
        await updateProduct(editingProduct.id, productData, token);
        showNotification("Product updated successfully!", "success");
      } else {
        await addProduct(productData, token);
        showNotification("Product added successfully!", "success");
      }

      handleCancelEdit();
      fetchProducts();
    } catch (err) {
      showNotification(`Failed to save product`, "error");
    } finally {
      setIsLoading(false);
    }
  };

  // ... (handleDelete and other functions are the same)

  // JSX with new file input
  return (
    <div className="max-w-3xl mx-auto">
      <Notification
        message={notification.message}
        type={notification.type}
        onClose={() =>
          setNotification({ message: "", type: "" as "success" | "error" })
        }
      />
      <h1 className="text-2xl font-bold mb-4">üì¶ Admin Product Manager</h1>
      <div className="bg-white p-4 rounded shadow mb-6">
        <h2 className="text-lg font-semibold mb-2">
          {editingProduct ? "‚úèÔ∏è Edit Product" : "‚ûï Add New Product"}
        </h2>

        <input
          type="text"
          name="name"
          placeholder="Name"
          value={form.name}
          onChange={handleInputChange}
          className="input-field"
        />
        <input
          type="text"
          name="description"
          placeholder="Description"
          value={form.description}
          onChange={handleInputChange}
          className="input-field"
        />
        <input
          type="number"
          name="price"
          placeholder="Price"
          value={form.price}
          onChange={handleInputChange}
          className="input-field"
        />

        {/* ‚úÖ New File Input Section */}
        <div className="mt-2">
          <label className="block text-sm font-medium text-gray-700">
            Product Image
          </label>
          <input
            type="file"
            accept="image/*"
            onChange={handleFileChange}
            className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
          />
          {/* Show existing or newly uploaded image preview */}
          {form.imageUrl && !selectedFile && (
            <img
              src={form.imageUrl}
              alt="Current Product"
              className="mt-2 h-24 w-24 object-cover"
            />
          )}
          {selectedFile && (
            <img
              src={URL.createObjectURL(selectedFile)}
              alt="New Preview"
              className="mt-2 h-24 w-24 object-cover"
            />
          )}
        </div>

        <div className="flex gap-2 mt-4">
          <button
            onClick={handleSubmit}
            className="btn-primary"
            disabled={isLoading}
          >
            {isUploading
              ? "Uploading..."
              : isLoading
              ? "Saving..."
              : editingProduct
              ? "Save Changes"
              : "Add Product"}
          </button>
          {editingProduct && (
            <button
              onClick={handleCancelEdit}
              className="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600"
            >
              Cancel
            </button>
          )}
        </div>
      </div>

      {/* ‚úÖ Updated Product List to show images */}
      <ul className="space-y-2">
        {products.map((p) => (
          <li
            key={p.id}
            className="bg-white p-4 rounded shadow flex justify-between items-center"
          >
            <div className="flex items-center gap-4">
              <img
                src={p.imageUrl || "https://via.placeholder.com/80"}
                alt={p.name}
                className="h-20 w-20 object-cover rounded"
              />
              <div>
                <p className="font-semibold">{p.name}</p>
                <p className="text-sm text-gray-500">{p.description}</p>
                <p className="text-green-600">${p.price}</p>
              </div>
            </div>
            <div className="flex gap-2">
              <button
                onClick={() => handleEditClick(p)}
                className="text-blue-600 hover:underline"
              >
                Edit
              </button>
              <button
                onClick={() => handleDelete(p.id)}
                className="text-red-600 hover:underline"
              >
                Delete
              </button>
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
}

"use client";

import PrivateRoute from "@/components/PrivateRoute";
import { useAuth } from "@/context/AuthContext";
import { getCartItems, removeFromCart } from "@/services/cart";
import { useEffect, useState } from "react";

type CartItem = {
  productId: number;
  name: string;
  description: string;
  price: number;
  quantity: number;
};

export default function CartPage() {
  const { token } = useAuth();

  const [cartItems, setCartItems] = useState<CartItem[]>([]);

  const fetchCart = async () => {
    if (!token) return;
    const items = await getCartItems(token);
    setCartItems(items);
  };

  const handleRemove = async (productId: number) => {
    if (!token) return;

    await removeFromCart(productId, token);
    fetchCart();
  };

  useEffect(() => {
    fetchCart();
  }, [token]);

  const totalPrice = cartItems.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );

  return (
    <PrivateRoute>
      <div className="p-4 max-w-2xl mx-auto">
        <h1 className="text-2xl font-bold mb-4">üõí Your Cart</h1>
        {cartItems.length === 0 ? (
          <p>Your cart is empty.</p>
        ) : (
          <div>
            <ul className="space-y-3">
              {cartItems.map((item) => (
                <li
                  key={item.productId}
                  className="border p-3 rounded flex justify-between items-center bg-white shadow-sm"
                >
                  <div>
                    <p className="font-semibold">{item.name}</p>
                    <p className="text-sm text-gray-500">{item.description}</p>

                    <p className="text-sm">
                      ${item.price.toFixed(2)} x {item.quantity}
                    </p>
                  </div>
                  <div className="text-right">
                    <p className="font-bold text-lg text-green-600">
                      ${(item.price * item.quantity).toFixed(2)}
                    </p>
                    <button
                      onClick={() => handleRemove(item.productId)}
                      className="text-red-500 hover:underline text-sm mt-1"
                    >
                      Remove
                    </button>
                  </div>
                </li>
              ))}
            </ul>

            <div className="text-right font-bold text-xl mt-4 border-t pt-4">
              Total: ${totalPrice.toFixed(2)}
            </div>
          </div>
        )}
      </div>
    </PrivateRoute>
  );
}

// app/login/page.tsx
"use client";

import { useState } from "react";
import { useAuth } from "@/context/AuthContext";
import axios from "axios";

export default function LoginPage() {
  const { login } = useAuth();
  const [form, setForm] = useState({ username: "", password: "" });
  const [error, setError] = useState("");

  const handleSubmit = async (e: any) => {
    e.preventDefault();
    try {
      const res = await axios.post(
        "http://localhost:8080/api/auth/login",
        form
      );
      login(res.data.token);
    } catch (err: any) {
      setError("Invalid credentials");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        placeholder="Username"
        value={form.username}
        onChange={(e) => setForm({ ...form, username: e.target.value })}
      />
      <input
        type="password"
        placeholder="Password"
        value={form.password}
        onChange={(e) => setForm({ ...form, password: e.target.value })}
      />
      <button type="submit">Login</button>
      {error && <p style={{ color: "red" }}>{error}</p>}
    </form>
  );
}

// app/login/page.tsx
"use client";

import { useState } from "react";
import { useAuth } from "@/context/AuthContext";
import axios from "axios";

export default function LoginPage() {
  const { login } = useAuth();
  const [form, setForm] = useState({ username: "", password: "" });
  const [error, setError] = useState("");

  const handleSubmit = async (e: any) => {
    e.preventDefault();
    try {
      const res = await axios.post(
        "http://localhost:8080/api/auth/login",
        form
      );
      login(res.data.token);
    } catch (err: any) {
      setError("Invalid credentials");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        placeholder="Username"
        value={form.username}
        onChange={(e) => setForm({ ...form, username: e.target.value })}
      />
      <input
        type="password"
        placeholder="Password"
        value={form.password}
        onChange={(e) => setForm({ ...form, password: e.target.value })}
      />
      <button type="submit">Login</button>
      {error && <p style={{ color: "red" }}>{error}</p>}
    </form>
  );
}

"use client";

import { useEffect, useState } from "react";
import axios from "axios";
import { useAuth } from "@/context/AuthContext";
import { addToCart } from "@/services/cart";
import { Product } from "@/types";

export default function ProductsPage() {
  const [products, setProducts] = useState<Product[]>([]);

  const { token } = useAuth();

  useEffect(() => {
    axios
      .get("http://localhost:8080/api/products")
      .then((res) => setProducts(res.data))
      .catch((err) => console.error("Error fetching products:", err));
  }, []);

  const handleAddToCart = async (productId: number) => {
    if (!token) {
      alert("You must be logged in to add to cart");
      return;
    }

    try {
      await addToCart(productId, 1, token);
      alert("Added to cart!");
    } catch (err) {
      console.error("Failed to add to cart:", err);
      alert("Failed to add to cart");
    }
  };

  return (
    <div>
      <h1 className="text-2xl font-bold mb-4">üõí Products</h1>
      <ul className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
        {products.map((product) => (
          <li
            key={product.id}
            className="border p-4 rounded shadow-sm bg-white hover:shadow-md transition"
          >
            <h2 className="font-bold text-lg">{product.name}</h2>
            <p className="text-sm text-gray-600">{product.description}</p>
            <p className="text-green-600 font-semibold mb-2">
              ${product.price}
            </p>
            <button
              onClick={() => handleAddToCart(product.id)}
              className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700"
            >
              Add to Cart
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}

"use client";

import { useState } from "react";
import axios from "axios";
import { useRouter } from "next/navigation";

export default function RegisterPage() {
  const router = useRouter();
  const [form, setForm] = useState({ username: "", email: "", password: "" });
  const [error, setError] = useState("");

  const handleSubmit = async (e: any) => {
    e.preventDefault();
    try {
      await axios.post("http://localhost:8080/api/auth/register", {
        username: form.username,
        email: form.email,
        password: form.password,
        role: "USER",
      });
      router.push("/login");
    } catch (err: any) {
      setError("Registration failed. Try a different username.");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        placeholder="Username"
        value={form.username}
        onChange={(e) => setForm({ ...form, username: e.target.value })}
      />
      <input
        placeholder="Email"
        value={form.email}
        onChange={(e) => setForm({ ...form, email: e.target.value })}
      />
      <input
        type="password"
        placeholder="Password"
        value={form.password}
        onChange={(e) => setForm({ ...form, password: e.target.value })}
      />
      <button type="submit">Register</button>
      {error && <p style={{ color: "red" }}>{error}</p>}
    </form>
  );
}

export default function Unauthorized() {
  return (
    <div>
      <h1>üö´ Unauthorized</h1>
      <p>You do not have permission to view this page.</p>
    </div>
  );
}

@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
.input-field {
  display: block;
  width: 100%;
  border: 1px solid #d1d5db; /* border-gray-300 */
  border-radius: 0.25rem; /* rounded */
  padding-left: 0.75rem; /* px-3 */
  padding-right: 0.75rem; /* px-3 */
  padding-top: 0.5rem; /* py-2 */
  padding-bottom: 0.5rem; /* py-2 */
  margin-bottom: 0.5rem; /* mb-2 */
}
.btn-primary {
  background-color: #2563eb; /* bg-blue-600 */
  color: #fff; /* text-white */
  padding-left: 1rem; /* px-4 */
  padding-right: 1rem; /* px-4 */
  padding-top: 0.5rem; /* py-2 */
  padding-bottom: 0.5rem; /* py-2 */
  border-radius: 0.25rem; /* rounded */
  transition: background-color 0.2s;
}
.btn-primary:hover {
  background-color: #1d4ed8; /* bg-blue-700 */
}

import "./globals.css";
import { AuthProvider } from "@/context/AuthContext";
import Navbar from "@/components/Navbar";

export const metadata = {
  title: "Mini Store",
  description: "Simple online store built with Next.js and Spring",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className="bg-gray-100 min-h-screen">
        <AuthProvider>
          <Navbar />
          <main className="p-4">{children}</main>
          <footer className="text-center py-4 text-gray-600 text-sm border-t mt-8">
            ¬© {new Date().getFullYear()} Mini Store
          </footer>
        </AuthProvider>
      </body>
    </html>
  );
}

// app/page.tsx (the main homepage)
import Link from "next/link";

export default function HomePage() {
  return (
    <div className="text-gray-800">
      <section className="bg-gradient-to-br from-blue-50 to-indigo-100 text-center py-20 sm:py-32">
        <div className="container mx-auto px-4">
          <h1 className="text-4xl sm:text-6xl font-extrabold tracking-tight text-gray-900">
            Welcome to Mini Store
          </h1>
          <p className="mt-4 text-lg sm:text-xl text-gray-600 max-w-2xl mx-auto">
            Your one-stop shop for the best products online. Discover quality
            and style in every click.
          </p>
          <div className="mt-8">
            <Link
              href="/products"
              className="inline-block bg-blue-600 text-white font-bold text-lg px-8 py-3 rounded-lg shadow-lg hover:bg-blue-700 transform hover:-translate-y-1 transition-all duration-300"
            >
              Shop Now ‚Üí
            </Link>
          </div>
        </div>
      </section>

      <section className="py-16 sm:py-24 bg-white">
        <div className="container mx-auto px-6 text-center">
          <h2 className="text-3xl font-bold mb-12">Why Shop With Us?</h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-12">
            {/* Feature 1 */}
            <div className="p-6">
              <div className="text-5xl mb-4">üì¶</div>
              <h3 className="text-xl font-semibold mb-2">Quality Products</h3>
              <p className="text-gray-500">
                We source the best products to ensure you get top-notch quality
                every time.
              </p>
            </div>

            <div className="p-6">
              <div className="text-5xl mb-4">üöö</div>
              <h3 className="text-xl font-semibold mb-2">Fast Shipping</h3>
              <p className="text-gray-500">
                Your order gets to you quickly and reliably, wherever you are.
              </p>
            </div>

            <div className="p-6">
              <div className="text-5xl mb-4">üîí</div>
              <h3 className="text-xl font-semibold mb-2">Secure Payments</h3>
              <p className="text-gray-500">
                Shop with confidence using our secure and encrypted payment
                gateway.
              </p>
            </div>
          </div>
        </div>
      </section>
    </div>
  );
}

"use client";

import Link from "next/link";
import { useAuth } from "@/context/AuthContext";
import { usePathname } from "next/navigation";

export default function Navbar() {
  const { user, token, logout } = useAuth();
  const pathname = usePathname();

  const navLinks = [
    { href: "/", label: "Home" },
    { href: "/products", label: "Products" },
  ];

  if (token) {
    navLinks.push({ href: "/cart", label: "Cart" });
  }
  if (user?.role === "ADMIN") {
    navLinks.push({ href: "/admin", label: "Admin" });
  }

  return (
    <header className="bg-white shadow-md sticky top-0 z-50">
      <nav className="container mx-auto px-6 py-3 flex justify-between items-center">
        {/* Logo & Main Links */}
        <div className="flex items-center gap-8">
          <Link href="/" className="text-xl font-bold text-gray-800">
            Mini Store üõçÔ∏è
          </Link>
          <div className="hidden md:flex items-center space-x-6">
            {navLinks.map((link) => {
              const isActive = pathname === link.href;
              return (
                <Link
                  key={link.label}
                  href={link.href}
                  className={`
                    ${
                      isActive ? "text-blue-600 font-semibold" : "text-gray-500"
                    }
                    hover:text-blue-600 transition-colors duration-200
                  `}
                >
                  {link.label}
                </Link>
              );
            })}
          </div>
        </div>

        <div className="flex items-center gap-4">
          {token ? (
            <>
              <span className="text-sm text-gray-600 hidden sm:block">
                Hello, {user.username}
              </span>
              <button
                onClick={logout}
                className="bg-red-500 text-white px-3 py-1 rounded-md text-sm font-medium hover:bg-red-600 transition"
              >
                Logout
              </button>
            </>
          ) : (
            <>
              <Link
                href="/login"
                className="text-gray-600 hover:text-blue-600 transition-colors"
              >
                Login
              </Link>
              <Link
                href="/register"
                className="bg-blue-600 text-white px-4 py-2 rounded-md text-sm font-medium hover:bg-blue-700 transition"
              >
                Register
              </Link>
            </>
          )}
        </div>
      </nav>
    </header>
  );
}

"use client";

interface NotificationProps {
  message: string;
  type: "success" | "error";
  onClose: () => void;
}

export default function Notification({
  message,
  type,
  onClose,
}: NotificationProps) {
  if (!message) return null;

  const baseClasses = "p-4 rounded-md text-white fixed top-5 right-5 z-50";
  const typeClasses = type === "success" ? "bg-green-500" : "bg-red-500";

  return (
    <div className={`${baseClasses} ${typeClasses}`}>
      <span>{message}</span>
      <button onClick={onClose} className="ml-4 font-bold">
        X
      </button>
    </div>
  );
}

"use client";

import { useAuth } from "@/context/AuthContext";
import { useEffect } from "react";
import { useRouter } from "next/navigation";

type Props = {
  children: React.ReactNode;
  requiredRole?: "USER" | "ADMIN";
};

export default function PrivateRoute({ children, requiredRole }: Props) {
  const { user, token, loading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading) {
      if (!token) {
        router.push("/login");
      } else if (requiredRole && user?.role !== requiredRole) {
        router.push("/unauthorized");
      }
    }
  }, [token, user, loading]);

  if (loading) {
    return <div>Loading...</div>;
  }

  if (!token || (requiredRole && user?.role !== requiredRole)) {
    return null;
  }

  return <>{children}</>;
}

"use client";
import {
  createContext,
  useState,
  useContext,
  useEffect,
  ReactNode,
} from "react";
import { jwtDecode } from "jwt-decode";
import { useRouter } from "next/navigation";

type AuthContextType = {
  user: any;
  token: string | null;
  login: (token: string) => void;
  logout: () => void;
  loading: boolean;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<any>(null);
  const [token, setToken] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    const storedToken = localStorage.getItem("token");
    if (storedToken) {
      setToken(storedToken);
      const decoded: any = jwtDecode(storedToken);
      setUser(decoded);
    }
    setLoading(false);
  }, []);

  const login = (newToken: string) => {
    localStorage.setItem("token", newToken);
    setToken(newToken);
    const decoded: any = jwtDecode(newToken);
    setUser(decoded);
    router.push("/");
  };

  const logout = () => {
    localStorage.removeItem("token");
    setUser(null);
    setToken(null);
    router.push("/login");
  };

  return (
    <AuthContext.Provider value={{ user, token, login, logout, loading }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
};

import axios from "axios";

const BASE_URL = "http://localhost:8080/api/cart";

export const addToCart = async (
  productId: number,
  quantity: number,
  token: string
) => {
  await axios.post(
    `${BASE_URL}`,
    { productId, quantity },
    {
      headers: { Authorization: `Bearer ${token}` },
    }
  );
};

export const getCartItems = async (token: string) => {
  const res = await axios.get(BASE_URL, {
    headers: { Authorization: `Bearer ${token}` },
  });
  return res.data;
};

export const removeFromCart = async (productId: number, token: string) => {
  await axios.delete(`${BASE_URL}/${productId}`, {
    headers: { Authorization: `Bearer ${token}` },
  });
};

import axios from "axios";
import { Product } from "@/types";

const API_URL = "http://localhost:8080/api/products";

export const getProducts = async (): Promise<Product[]> => {
  const response = await axios.get(API_URL);
  return response.data;
};

export const addProduct = async (
  productData: Omit<Product, "id">,
  token: string
): Promise<Product> => {
  const response = await axios.post(API_URL, productData, {
    headers: { Authorization: `Bearer ${token}` },
  });
  return response.data;
};

export const updateProduct = async (
  id: number,
  productData: Partial<Product>,
  token: string
): Promise<Product> => {
  const response = await axios.put(`${API_URL}/${id}`, productData, {
    headers: { Authorization: `Bearer ${token}` },
  });
  return response.data;
};

export const deleteProduct = async (
  id: number,
  token: string
): Promise<void> => {
  await axios.delete(`${API_URL}/${id}`, {
    headers: { Authorization: `Bearer ${token}` },
  });
};

export interface Product {
  id: number;
  name: string;
  description: string;
  price: number;
  imageUrl?: string;
  quantity?: number;
}

Backend:
package com.mjcoder.ecommerce.controller;

import com.mjcoder.ecommerce.dto.LoginRequest;
import com.mjcoder.ecommerce.dto.LoginResponse;
import com.mjcoder.ecommerce.dto.RegisterRequest;
import com.mjcoder.ecommerce.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController

@RequestMapping("/api/auth")

public class AuthController {

    @Autowired
    private UserService userService;

    @PostMapping("/register")
    public ResponseEntity<String> register(@RequestBody RegisterRequest request) {
        userService.register(request);
        return ResponseEntity.ok("User registered successfully");
    }

    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@RequestBody LoginRequest request) {
        LoginResponse response = userService.login(request);
        return ResponseEntity.ok(response);
    }
}

package com.mjcoder.ecommerce.controller;

import com.mjcoder.ecommerce.dto.CartRequest;
import com.mjcoder.ecommerce.model.CartItem;
import com.mjcoder.ecommerce.service.CartItemService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import com.mjcoder.ecommerce.dto.CartItemResponse;

import java.util.List;
import org.springframework.web.bind.annotation.CrossOrigin;

@RestController
@RequestMapping("/api/cart")
@PreAuthorize("hasRole('USER')")
public class CartController {

    @Autowired
    private CartItemService cartItemService;

    // Get cart items for current user
    @GetMapping
    public ResponseEntity<List<CartItemResponse>> getCart(Authentication authentication) {
        String username = authentication.getName();
        return ResponseEntity.ok(cartItemService.getUserCart(username));
    }

    // Add product to cart
    @PostMapping
    public ResponseEntity<Void> addToCart(@RequestBody CartRequest request, Authentication authentication) {
        String username = authentication.getName();
        cartItemService.addToCart(username, request.getProductId(), request.getQuantity());
        return ResponseEntity.ok().build();
    }

    // Remove product from cart
    @DeleteMapping("/{productId}")
    public ResponseEntity<Void> removeFromCart(@PathVariable Long productId, Authentication authentication) {
        String username = authentication.getName();
        cartItemService.removeFromCart(username, productId);
        return ResponseEntity.ok().build();
    }
}

package com.mjcoder.ecommerce.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

@RestController
@RequestMapping("/api/upload")
public class FileUploadController {

    private final Path rootLocation = Paths.get("uploads");

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')") // Only Admins can upload
    public ResponseEntity<?> uploadFile(@RequestParam("file") MultipartFile file) {
        try {
            if (file.isEmpty()) {
                throw new RuntimeException("Failed to store empty file.");
            }
            // Create the 'uploads' directory if it doesn't exist
            if (!Files.exists(rootLocation)) {
                Files.createDirectories(rootLocation);
            }

            // Generate a unique filename to prevent overwrites
            String originalFilename = file.getOriginalFilename();
            String extension = "";
            if (originalFilename != null && originalFilename.contains(".")) {
                extension = originalFilename.substring(originalFilename.lastIndexOf("."));
            }
            String uniqueFilename = UUID.randomUUID().toString() + extension;

            // Save the file to the 'uploads' directory
            Files.copy(file.getInputStream(), this.rootLocation.resolve(uniqueFilename));

            // Build the public URL for the file
            String fileUrl = ServletUriComponentsBuilder.fromCurrentContextPath()
                    .path("/images/")
                    .path(uniqueFilename)
                    .toUriString();

            // Return the URL in a JSON object: { "url": "http://localhost:8080/images/..." }
            return ResponseEntity.ok().body(java.util.Collections.singletonMap("url", fileUrl));

        } catch (IOException e) {
            throw new RuntimeException("Failed to store file.", e);
        }
    }
}

package com.mjcoder.ecommerce.controller;

import com.mjcoder.ecommerce.model.Product;
import com.mjcoder.ecommerce.service.ProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products")
public class ProductController {

    @Autowired
    private ProductService productService;

    // Anyone can view products
    @GetMapping
    public ResponseEntity<List<Product>> getAll() {
        return ResponseEntity.ok(productService.getAllProducts());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Product> getOne(@PathVariable Long id) {
        return ResponseEntity.ok(productService.getProduct(id));
    }

    // Admin only
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Product> add(@RequestBody Product product) {
        return ResponseEntity.ok(productService.addProduct(product));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Product> update(@PathVariable Long id, @RequestBody Product product) {
        return ResponseEntity.ok(productService.updateProduct(id, product));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        productService.deleteProduct(id);
        return ResponseEntity.noContent().build();
    }
}

package com.mjcoder.ecommerce.dto;

import com.mjcoder.ecommerce.model.CartItem;
import lombok.Data;

@Data
public class CartItemResponse {

    private Long productId;
    private String name;
    private String description;
    private double price;
    private int quantity;
    private String imageUrl;

    // A constructor to easily convert from a CartItem entity
    public CartItemResponse(CartItem cartItem) {
        this.productId = cartItem.getProduct().getId();
        this.name = cartItem.getProduct().getName();
        this.description = cartItem.getProduct().getDescription();
        this.price = cartItem.getProduct().getPrice();
        this.quantity = cartItem.getQuantity();
        this.imageUrl = cartItem.getProduct().getImageUrl();
    }
}

package com.mjcoder.ecommerce.dto;

import lombok.Data;

@Data
public class CartRequest {
    private Long productId;
    private int quantity;
}

package com.mjcoder.ecommerce.dto;

import lombok.Data;

@Data
public class LoginRequest {
    private String username;
    private String password;
}

package com.mjcoder.ecommerce.dto;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class LoginResponse {
    private String token;
}

package com.mjcoder.ecommerce.dto;

import lombok.Data;

@Data
public class RegisterRequest {
    private String username;
    private String email;
    private String password;
}

package com.mjcoder.ecommerce.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    private User user;

    @ManyToOne
    private Product product;

    private int quantity;
}

package com.mjcoder.ecommerce.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String description;

    private double price;

    private int quantity;

    private String imageUrl;
}

package com.mjcoder.ecommerce.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;

    private String email;

    private String password;

    private String role; 
    
}

package com.mjcoder.ecommerce.repository;

import com.mjcoder.ecommerce.model.CartItem;
import com.mjcoder.ecommerce.model.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface CartItemRepository extends JpaRepository<CartItem, Long> {
    List<CartItem> findByUser(User user);
    Optional<CartItem> findByUserAndProduct(User user, com.mjcoder.ecommerce.model.Product product);
}

package com.mjcoder.ecommerce.repository;

import org.springframework.data.jpa.repository.JpaRepository;


import com.mjcoder.ecommerce.model.Product;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ProductRepository extends JpaRepository<Product, Long> {
    
}

package com.mjcoder.ecommerce.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.mjcoder.ecommerce.model.User;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    boolean existsByUsername(String username);
    boolean existsByEmail(String email);
}

package com.mjcoder.ecommerce.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import com.mjcoder.ecommerce.service.CustomUserDetailsService;

import java.io.IOException;

@Component

public class JwtAuthFilter extends OncePerRequestFilter {


    @Autowired
    private JwtUtil jwtUtil; 

    @Autowired
    private CustomUserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");
        final String jwt;
        final String username;

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        jwt = authHeader.substring(7);
        // **MODIFICATION HERE**
        username = jwtUtil.extractUsername(jwt);

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);

            // **MODIFICATION HERE**
            if (jwtUtil.validateToken(jwt, userDetails)) {
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                );
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }
}

package com.mjcoder.ecommerce.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtil {

    private final Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);

    private final long jwtExpirationMs = 24 * 60 * 60 * 1000; 


    public String generateToken(String username, String role) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("role", role);
        return createToken(claims, username);
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpirationMs))
                .signWith(key)
                .compact();
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
    
    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }


    public boolean validateToken(String token, UserDetails userDetails) {
        try {
            final String username = extractUsername(token);

            return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
        } catch (JwtException | IllegalArgumentException e) {
            System.err.println("Invalid JWT token: " + e.getMessage());
        }
        return false;
    }
}

package com.mjcoder.ecommerce.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableMethodSecurity
public class SecurityConfig {

    @Autowired
    private JwtAuthFilter jwtAuthFilter;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http

            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            
            // Basic security setup
            .csrf(csrf -> csrf.disable())
            .sessionManagement(sess -> sess.sessionCreationPolicy(SessionCreationPolicy.STATELESS))


            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers(HttpMethod.GET, "/api/products", "/api/products/**").permitAll()
                .requestMatchers("/api/products/**", "/api/upload/**").hasRole("ADMIN")
                .requestMatchers("/api/products/**").hasRole("ADMIN")
                .requestMatchers("/api/cart/**").hasRole("USER")
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }


    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}

package com.mjcoder.ecommerce.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;


@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**") // Apply to all API routes
                        .allowedOrigins("http://localhost:3000") 
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") // Allow specific HTTP methods
                        .allowedHeaders("*") // Allow all headers
                        .allowCredentials(true);
            }
        };
    }
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {

        registry.addResourceHandler("/images/**")
                .addResourceLocations("file:uploads/");
    }
}

package com.mjcoder.ecommerce.service;

import com.mjcoder.ecommerce.model.CartItem;
import com.mjcoder.ecommerce.model.Product;
import com.mjcoder.ecommerce.model.User;
import com.mjcoder.ecommerce.repository.CartItemRepository;
import com.mjcoder.ecommerce.repository.ProductRepository;
import com.mjcoder.ecommerce.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.mjcoder.ecommerce.dto.CartItemResponse; 
import java.util.stream.Collectors;


import java.util.List;

@Service
public class CartItemService {

    @Autowired
    private CartItemRepository cartItemRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ProductRepository productRepository;

    public List<CartItemResponse> getUserCart(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));
        
        List<CartItem> cartItems = cartItemRepository.findByUser(user);

        // Convert each CartItem entity into a CartItemResponse DTO
        return cartItems.stream()
                .map(CartItemResponse::new) // This uses the constructor we created
                .collect(Collectors.toList());
    }

    public void addToCart(String username, Long productId, int quantity) {
        User user = userRepository.findByUsername(username).orElseThrow();
        Product product = productRepository.findById(productId).orElseThrow();

        CartItem existing = cartItemRepository.findByUserAndProduct(user, product).orElse(null);

        if (existing != null) {
            existing.setQuantity(existing.getQuantity() + quantity);
            cartItemRepository.save(existing);
        } else {
            CartItem newItem = CartItem.builder()
                    .user(user)
                    .product(product)
                    .quantity(quantity)
                    .build();
            cartItemRepository.save(newItem);
        }
    }

    public void removeFromCart(String username, Long productId) {
        User user = userRepository.findByUsername(username).orElseThrow();
        Product product = productRepository.findById(productId).orElseThrow();

        CartItem item = cartItemRepository.findByUserAndProduct(user, product)
                .orElseThrow(() -> new RuntimeException("Item not found in cart"));

        cartItemRepository.delete(item);
    }
}

package com.mjcoder.ecommerce.service;

import com.mjcoder.ecommerce.model.User;
import com.mjcoder.ecommerce.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.*;
import org.springframework.stereotype.Service;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                     .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        return org.springframework.security.core.userdetails.User
                .withUsername(user.getUsername())
                .password(user.getPassword())
                .roles(user.getRole()) 
                .build();
    }
}

package com.mjcoder.ecommerce.service;

import com.mjcoder.ecommerce.model.Product;
import com.mjcoder.ecommerce.repository.ProductRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    public Product addProduct(Product product) {
        return productRepository.save(product);
    }

    public Product updateProduct(Long id, Product updatedProduct) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Product not found"));

        product.setName(updatedProduct.getName());
        product.setDescription(updatedProduct.getDescription());
        product.setPrice(updatedProduct.getPrice());
        product.setQuantity(updatedProduct.getQuantity());
        product.setImageUrl(updatedProduct.getImageUrl());

        return productRepository.save(product);
    }

    public void deleteProduct(Long id) {
        if (!productRepository.existsById(id)) {
            throw new RuntimeException("Product not found");
        }
        productRepository.deleteById(id);
    }

    public List<Product> getAllProducts() {
        return productRepository.findAll();
    }

    public Product getProduct(Long id) {
        return productRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Product not found"));
    }
}

package com.mjcoder.ecommerce.service;

import com.mjcoder.ecommerce.dto.LoginRequest;
import com.mjcoder.ecommerce.dto.LoginResponse;
import com.mjcoder.ecommerce.dto.RegisterRequest;
import com.mjcoder.ecommerce.model.User;
import com.mjcoder.ecommerce.repository.UserRepository;
import com.mjcoder.ecommerce.security.JwtUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JwtUtil jwtUtil; // This dependency is now correct

    public void register(RegisterRequest request) {
        // ... (no changes here)
        if(userRepository.existsByUsername(request.getUsername()))
            throw new RuntimeException("Username already taken");
        if(userRepository.existsByEmail(request.getEmail()))
            throw new RuntimeException("Email already registered");

        User user = User.builder()
                .username(request.getUsername())
                .email(request.getEmail())
                .password(passwordEncoder.encode(request.getPassword()))
                .role("USER") 
                .build();

        userRepository.save(user);
    }

    public LoginResponse login(LoginRequest request) {
        Optional<User> userOpt = userRepository.findByUsername(request.getUsername());
        if(userOpt.isEmpty())
            throw new RuntimeException("Invalid username or password");

        User user = userOpt.get();

        if(!passwordEncoder.matches(request.getPassword(), user.getPassword()))
            throw new RuntimeException("Invalid username or password");


        String token = jwtUtil.generateToken(user.getUsername(), user.getRole());

        return new LoginResponse(token);
    }
}

package com.mjcoder.ecommerce;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class EcommerceApplication {

	public static void main(String[] args) {
		SpringApplication.run(EcommerceApplication.class, args);
	}

}
